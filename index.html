<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Replacer</title>
    <style>
        body {
            margin: 0;
            font-family: Consolas, 'Courier New', monospace;
            display: flex;
            height: 100vh;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        
        .panel {
            width: 50%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        
        .left-panel {
            background-color: #0d1117;
            border-right: 2px solid #30363d;
        }
        
        .right-panel {
            background-color: #161b22;
        }
        
        h3 {
            margin: 10px 0;
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .function-count {
            color: #7d8590;
            font-weight: normal;
            font-size: 12px;
        }
        
        textarea {
            width: 100%;
            height: 100%;
            font-family: Consolas, 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid #30363d;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
            background-color: #0d1117;
            color: #c9d1d9;
            border-radius: 6px;
        }
        
        textarea:focus {
            outline: none;
            border-color: #58a6ff;
        }
        
        .function-list {
            height: 45%;
            overflow-y: auto;
            border: 1px solid #30363d;
            margin-bottom: 10px;
            background: #0d1117;
            border-radius: 6px;
        }
        
        .function-list::-webkit-scrollbar {
            width: 10px;
        }
        
        .function-list::-webkit-scrollbar-track {
            background: #161b22;
        }
        
        .function-list::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 5px;
        }
        
        .function-list::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
        
        .function-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #21262d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            transition: background-color 0.1s ease;
            min-width: 0;
        }
        
        .function-item:hover {
            background-color: #161b22;
        }
        
        .function-item.selected {
            background-color: #1f6feb;
            color: white;
        }
        
        .function-item .class-name {
            color: #58a6ff;
            font-weight: 600;
        }
        
        .function-item .separator {
            color: #484f58;
            margin: 0 5px;
        }
        
        .function-item .func-name {
            font-weight: 600;
            color: #f0f6fc;
        }
        
        .function-item.selected .class-name {
            color: #a5d6ff;
        }
        
        .function-item.selected .separator {
            color: #8b949e;
        }
        
        .function-item.selected .func-name {
            color: #fff;
        }
        
        .replacement-area {
            height: 55%;
            display: flex;
            flex-direction: column;
        }
        
        button {
            margin-top: 10px;
            padding: 10px;
            background-color: #238636;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-family: Consolas, 'Courier New', monospace;
            border-radius: 6px;
            font-weight: 600;
            transition: background-color 0.1s ease;
        }
        
        button:hover {
            background-color: #2ea043;
        }
        
        button:disabled {
            background-color: #21262d;
            color: #484f58;
            cursor: not-allowed;
        }
        
        textarea::placeholder {
            color: #484f58;
        }
    </style>
</head>
<body>
    <div class="panel left-panel">
        <h3>Original Code</h3>
        <textarea id="originalCode" placeholder="Paste your JavaScript file here...

Supports: class methods, regular functions, arrow functions, object methods, async functions, etc."></textarea>
    </div>
    
    <div class="panel right-panel">
        <h3>
            <span>Functions</span>
            <span class="function-count" id="functionCount"></span>
        </h3>
        <div id="functionList" class="function-list"></div>
        
        <div class="replacement-area">
            <h3>Replace Function</h3>
            <textarea id="replacementCode" placeholder="Paste new function code here..."></textarea>
            <button id="replaceButton" onclick="replaceFunction()" disabled>Replace Function</button>
        </div>
    </div>
    
    <script>
        let functions = [];
        let selectedFunction = null;
        let originalText = '';
        let detectedClasses = new Set();
        
        document.getElementById('originalCode').addEventListener('input', parseCode);
        
        function parseCode() {
            const code = document.getElementById('originalCode').value;
            originalText = code;
            functions = [];
            detectedClasses = new Set();
            
            if (!code.trim()) {
                updateFunctionCount();
                displayFunctions();
                return;
            }
            
            // First, find all class declarations
            const classPattern = /class\s+(\w+)(?:\s+extends\s+\w+)?\s*{/g;
            let classMatch;
            const classPositions = new Map();
            
            while ((classMatch = classPattern.exec(code)) !== null) {
                const className = classMatch[1];
                if (!isReservedWord(className)) {
                    detectedClasses.add(className);
                    // Find the end of this class
                    const classStart = classMatch.index;
                    const bracePos = code.indexOf('{', classStart);
                    const classEnd = findMatchingBrace(code, bracePos);
                    if (classEnd !== -1) {
                        classPositions.set(className, { start: classStart, end: classEnd });
                    }
                }
            }
            
            // Find all functions using multiple patterns
            const patterns = [
                // Getter methods: get propertyName() {
                /\bget\s+(\w+)\s*\(\s*\)\s*{/g,
                // Setter methods: set propertyName(value) {
                /\bset\s+(\w+)\s*\([^)]+\)\s*{/g,
                // Class methods (more specific - requires newline or start of line before)
                /(?:^|\n)\s*(?:async\s+)?(?:static\s+)?([a-zA-Z_]\w*)\s*\([^)]*\)\s*{/gm,
                // Regular function declarations
                /\bfunction\s+(\w+)\s*\([^)]*\)\s*{/g,
                // Arrow functions assigned to variables
                /\b(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?(?:\([^)]*\)|\w+)\s*=>\s*{/g,
                // Object methods with function keyword
                /(\w+)\s*:\s*(?:async\s+)?function\s*\([^)]*\)\s*{/g,
                // Object methods with arrow functions
                /(\w+)\s*:\s*(?:async\s+)?(?:\([^)]*\)|\w+)\s*=>\s*{/g
            ];
            
            const allMatches = [];
            
            patterns.forEach((pattern, patternIndex) => {
                pattern.lastIndex = 0;
                let match;
                while ((match = pattern.exec(code)) !== null) {
                    let actualStart = match.index;
                    
                    // For getter/setter patterns (first two patterns), adjust start position
                    if (patternIndex <= 1) {
                        // The match.index points to 'get' or 'set', which is what we want
                        actualStart = match.index;
                    }
                    
                    allMatches.push({
                        name: match[1],
                        start: actualStart,
                        fullMatch: match[0],
                        isGetter: patternIndex === 0,
                        isSetter: patternIndex === 1
                    });
                }
            });
            
            // Process matches
            allMatches.forEach(matchInfo => {
                const name = matchInfo.name;
                const start = matchInfo.start;
                
                // Skip keywords and reserved words
                if (isReservedWord(name) || name === 'constructor') {
                    return;
                }
                
                // Skip if it's a class name (classes are not functions)
                if (detectedClasses.has(name)) {
                    return;
                }
                
                // Find opening brace
                const bracePos = code.indexOf('{', start);
                if (bracePos === -1 || bracePos > start + matchInfo.fullMatch.length) return;
                
                // Find closing brace
                const endPos = findMatchingBrace(code, bracePos);
                if (endPos === -1) return;
                
                const functionText = code.substring(start, endPos + 1);
                
                // Check for duplicates
                const isDuplicate = functions.some(f => 
                    Math.abs(f.start - start) < 5 && f.name === name
                );
                
                if (!isDuplicate) {
                    // Find which class this function belongs to
                    let className = null;
                    for (const [cls, pos] of classPositions) {
                        if (start > pos.start && start < pos.end) {
                            className = cls;
                            break;
                        }
                    }
                    
                    functions.push({
                        name: name,
                        className: className,
                        text: functionText,
                        start: start,
                        end: endPos + 1
                    });
                }
            });
            
            // Sort by class first, then alphabetically within each class
            functions.sort((a, b) => {
                // First sort by whether they have a class or not
                if (a.className && !b.className) return -1;
                if (!a.className && b.className) return 1;
                
                // Then sort by class name
                if (a.className && b.className && a.className !== b.className) {
                    return a.className.localeCompare(b.className);
                }
                
                // Finally sort by function name within the same class
                return a.name.localeCompare(b.name);
            });
            
            // Debug: Check if classes were detected
            console.log('Functions found:', functions.length);
            console.log('Classes detected:', Array.from(detectedClasses));
            
            updateFunctionCount();
            displayFunctions();
        }
        
        function isReservedWord(word) {
            const reserved = [
                'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 
                'continue', 'return', 'try', 'catch', 'finally', 'throw', 'new', 
                'this', 'super', 'class', 'function', 'const', 'let', 'var',
                'true', 'false', 'null', 'undefined', 'typeof', 'instanceof',
                'delete', 'void', 'yield', 'async', 'await', 'import', 'export',
                'default', 'extends', 'static', 'get', 'set', 'of', 'in'
            ];
            
            // Built-in array/object methods to exclude
            const builtInMethods = [
                'forEach', 'map', 'filter', 'reduce', 'find', 'findIndex', 'some', 'every',
                'push', 'pop', 'shift', 'unshift', 'slice', 'splice', 'indexOf', 'includes',
                'sort', 'reverse', 'join', 'split', 'toString', 'valueOf', 'hasOwnProperty',
                'preventDefault', 'stopPropagation', 'addEventListener', 'removeEventListener',
                'querySelector', 'querySelectorAll', 'getElementById', 'getElementsByClassName',
                'createElement', 'appendChild', 'removeChild', 'setAttribute', 'getAttribute',
                'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
                'then', 'catch', 'finally', 'resolve', 'reject',
                'log', 'error', 'warn', 'info', 'debug', 'trace',
                'random', 'floor', 'ceil', 'round', 'max', 'min', 'abs', 'sqrt', 'pow',
                'startsWith', 'endsWith', 'padStart', 'padEnd', 'trim', 'toLowerCase', 'toUpperCase',
                'keys', 'values', 'entries', 'assign', 'freeze', 'seal'
            ];
            
            return reserved.includes(word.toLowerCase()) || builtInMethods.includes(word);
        }
        
        function findMatchingBrace(code, startPos) {
            let depth = 0;
            let inString = false;
            let stringChar = '';
            let inComment = false;
            let inMultiComment = false;
            
            for (let i = startPos; i < code.length; i++) {
                const char = code[i];
                const prevChar = i > 0 ? code[i-1] : '';
                const nextChar = i < code.length - 1 ? code[i+1] : '';
                
                // Skip escaped characters
                if (prevChar === '\\' && inString) continue;
                
                // Handle comments
                if (!inString) {
                    if (char === '/' && nextChar === '/' && !inComment && !inMultiComment) {
                        inComment = true;
                        continue;
                    }
                    if (char === '/' && nextChar === '*' && !inComment && !inMultiComment) {
                        inMultiComment = true;
                        i++; // Skip the *
                        continue;
                    }
                    if (char === '*' && nextChar === '/' && inMultiComment) {
                        inMultiComment = false;
                        i++; // Skip the /
                        continue;
                    }
                    if (char === '\n' && inComment) {
                        inComment = false;
                        continue;
                    }
                }
                
                // Skip if in comment
                if (inComment || inMultiComment) continue;
                
                // Handle strings
                if (!inString) {
                    if (char === '"' || char === "'" || char === '`') {
                        inString = true;
                        stringChar = char;
                    } else if (char === '{') {
                        depth++;
                    } else if (char === '}') {
                        depth--;
                        if (depth === 0) return i;
                    }
                } else {
                    if (char === stringChar) {
                        inString = false;
                    }
                }
            }
            
            return -1;
        }
        
        function updateFunctionCount() {
            const countEl = document.getElementById('functionCount');
            if (functions.length > 0) {
                countEl.textContent = ' (' + functions.length + ')';
            } else {
                countEl.textContent = '';
            }
            console.log('Updated function count:', functions.length);
        }
        
        function displayFunctions() {
            const list = document.getElementById('functionList');
            list.innerHTML = '';
            
            functions.forEach((func, index) => {
                const div = document.createElement('div');
                div.className = 'function-item';
                
                // Get function signature
                const braceIndex = func.text.indexOf('{');
                const signature = func.text.substring(0, braceIndex + 1).trim();
                const shortSig = signature.length > 80 ? signature.substring(0, 77) + '...' : signature;
                
                // Create display elements
                const classSpan = document.createElement('span');
                classSpan.className = 'class-name';
                
                const sepSpan = document.createElement('span');
                sepSpan.className = 'separator';
                sepSpan.textContent = ' | ';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'func-name';
                nameSpan.textContent = func.name;
                
                const sigSpan = document.createElement('span');
                sigSpan.textContent = ' - ' + shortSig;
                
                if (func.className) {
                    classSpan.textContent = func.className;
                    div.appendChild(classSpan);
                    div.appendChild(sepSpan);
                }
                
                div.appendChild(nameSpan);
                div.appendChild(sigSpan);
                
                div.title = func.className ? `${func.className} | ${signature}` : signature;
                div.onclick = function() { selectFunction(index); };
                
                list.appendChild(div);
            });
            
            document.getElementById('replaceButton').disabled = true;
            selectedFunction = null;
        }
        
        function selectFunction(index) {
            selectedFunction = functions[index];
            
            // Update UI
            const items = document.querySelectorAll('.function-item');
            items.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            
            document.getElementById('replaceButton').disabled = false;
            document.getElementById('replacementCode').value = selectedFunction.text;
        }
        
        function replaceFunction() {
            if (!selectedFunction) return;
            
            const replacementCode = document.getElementById('replacementCode').value;
            const currentCode = document.getElementById('originalCode').value;
            
            // Replace the function
            const newCode = currentCode.substring(0, selectedFunction.start) + 
                           replacementCode + 
                           currentCode.substring(selectedFunction.end);
            
            document.getElementById('originalCode').value = newCode;
            
            // Re-parse
            parseCode();
            
            // Clear replacement area
            document.getElementById('replacementCode').value = '';
        }
    </script>
</body>
</html>
